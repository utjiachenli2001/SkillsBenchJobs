{
    "results": {
        "tool": {
            "name": "pytest",
            "version": "8.4.1"
        },
        "summary": {
            "tests": 46,
            "passed": 4,
            "failed": 42,
            "skipped": 0,
            "pending": 0,
            "other": 0,
            "start": 1768586831.4564383,
            "stop": 1768586833.5639925
        },
        "tests": [
            {
                "name": "test_outputs.py::TestFilesExist::test_pid_controller_exists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.00044991899994784035,
                "start": 1768586831.4910367,
                "stop": 1768586831.5005372,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestFilesExist object at 0x7ce3035a8e60>\n\n    def test_pid_controller_exists(self):\n        \"\"\"Step 1: /root/pid_controller.py\"\"\"\n>       assert os.path.exists('/root/pid_controller.py')\nE       AssertionError: assert False\nE        +  where False = <function exists at 0x7ce303773560>('/root/pid_controller.py')\nE        +    where <function exists at 0x7ce303773560> = <module 'posixpath' (frozen)>.exists\nE        +      where <module 'posixpath' (frozen)> = os.path\n\n/tests/test_outputs.py:19: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::TestFilesExist::test_acc_system_exists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0004128909995415597,
                "start": 1768586831.500771,
                "stop": 1768586831.505762,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestFilesExist object at 0x7ce3029e9e50>\n\n    def test_acc_system_exists(self):\n        \"\"\"Step 2: /root/acc_system.py\"\"\"\n>       assert os.path.exists('/root/acc_system.py')\nE       AssertionError: assert False\nE        +  where False = <function exists at 0x7ce303773560>('/root/acc_system.py')\nE        +    where <function exists at 0x7ce303773560> = <module 'posixpath' (frozen)>.exists\nE        +      where <module 'posixpath' (frozen)> = os.path\n\n/tests/test_outputs.py:23: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::TestFilesExist::test_simulation_exists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0003103239996562479,
                "start": 1768586831.5059848,
                "stop": 1768586831.5105681,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestFilesExist object at 0x7ce3029e9c10>\n\n    def test_simulation_exists(self):\n        \"\"\"Step 3: /root/simulation.py\"\"\"\n>       assert os.path.exists('/root/simulation.py')\nE       AssertionError: assert False\nE        +  where False = <function exists at 0x7ce303773560>('/root/simulation.py')\nE        +    where <function exists at 0x7ce303773560> = <module 'posixpath' (frozen)>.exists\nE        +      where <module 'posixpath' (frozen)> = os.path\n\n/tests/test_outputs.py:27: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::TestFilesExist::test_tuning_results_exists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.00029784200069116196,
                "start": 1768586831.510763,
                "stop": 1768586831.5153282,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestFilesExist object at 0x7ce3029e94c0>\n\n    def test_tuning_results_exists(self):\n        \"\"\"Step 4: /root/tuning_results.yaml\"\"\"\n>       assert os.path.exists('/root/tuning_results.yaml')\nE       AssertionError: assert False\nE        +  where False = <function exists at 0x7ce303773560>('/root/tuning_results.yaml')\nE        +    where <function exists at 0x7ce303773560> = <module 'posixpath' (frozen)>.exists\nE        +      where <module 'posixpath' (frozen)> = os.path\n\n/tests/test_outputs.py:31: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::TestFilesExist::test_simulation_results_exists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.00029042400092293974,
                "start": 1768586831.5155263,
                "stop": 1768586831.5200427,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestFilesExist object at 0x7ce3029e9be0>\n\n    def test_simulation_results_exists(self):\n        \"\"\"Step 5: /root/simulation_results.csv\"\"\"\n>       assert os.path.exists('/root/simulation_results.csv')\nE       AssertionError: assert False\nE        +  where False = <function exists at 0x7ce303773560>('/root/simulation_results.csv')\nE        +    where <function exists at 0x7ce303773560> = <module 'posixpath' (frozen)>.exists\nE        +      where <module 'posixpath' (frozen)> = os.path\n\n/tests/test_outputs.py:35: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::TestFilesExist::test_acc_report_exists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0003388010009075515,
                "start": 1768586831.5202308,
                "stop": 1768586831.5324397,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestFilesExist object at 0x7ce3029e9730>\n\n    def test_acc_report_exists(self):\n        \"\"\"Step 6: /root/acc_report.md\"\"\"\n>       assert os.path.exists('/root/acc_report.md')\nE       AssertionError: assert False\nE        +  where False = <function exists at 0x7ce303773560>('/root/acc_report.md')\nE        +    where <function exists at 0x7ce303773560> = <module 'posixpath' (frozen)>.exists\nE        +      where <module 'posixpath' (frozen)> = os.path\n\n/tests/test_outputs.py:39: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::TestInputFilesIntegrity::test_sensor_data_row_count",
                "status": "passed",
                "duration": 1.098055309999836,
                "start": 1768586831.5325935,
                "stop": 1768586832.630888,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::TestInputFilesIntegrity::test_sensor_data_columns",
                "status": "passed",
                "duration": 0.0008675369990669424,
                "start": 1768586832.6310737,
                "stop": 1768586832.6321337,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::TestInputFilesIntegrity::test_sensor_data_time_range",
                "status": "passed",
                "duration": 0.0008859129993652459,
                "start": 1768586832.6322856,
                "stop": 1768586832.6333537,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::TestInputFilesIntegrity::test_vehicle_params_unchanged",
                "status": "passed",
                "duration": 0.03161561400065693,
                "start": 1768586832.6334965,
                "stop": 1768586832.6653297,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::TestPIDController::test_pid_class_exists",
                "status": "failed",
                "duration": 0.00027396299992688,
                "start": 1768586832.6654956,
                "stop": 1768586832.680413,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestPIDController object at 0x7ce3029e8fe0>\n\n    @pytest.fixture\n    def pid_module(self):\n        spec = importlib.util.spec_from_file_location('pid_controller', '/root/pid_controller.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2b02c2ff0>\npath = '/root/pid_controller.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/pid_controller.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestPIDController::test_pid_methods",
                "status": "failed",
                "duration": 0.0002330979996258975,
                "start": 1768586832.6805892,
                "stop": 1768586832.6854424,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestPIDController object at 0x7ce3029e8e90>\n\n    @pytest.fixture\n    def pid_module(self):\n        spec = importlib.util.spec_from_file_location('pid_controller', '/root/pid_controller.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afed3ec0>\npath = '/root/pid_controller.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/pid_controller.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestPIDController::test_pid_proportional_response",
                "status": "failed",
                "duration": 0.00020474499979172833,
                "start": 1768586832.685616,
                "stop": 1768586832.69052,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestPIDController object at 0x7ce3029e89e0>\n\n    @pytest.fixture\n    def pid_module(self):\n        spec = importlib.util.spec_from_file_location('pid_controller', '/root/pid_controller.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afed4470>\npath = '/root/pid_controller.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/pid_controller.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestPIDController::test_pid_integral_accumulation",
                "status": "failed",
                "duration": 0.00021663699953933246,
                "start": 1768586832.6906755,
                "stop": 1768586832.6955566,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestPIDController object at 0x7ce3029e94f0>\n\n    @pytest.fixture\n    def pid_module(self):\n        spec = importlib.util.spec_from_file_location('pid_controller', '/root/pid_controller.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afed8a70>\npath = '/root/pid_controller.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/pid_controller.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestACCSystem::test_acc_class_exists",
                "status": "failed",
                "duration": 0.00020695200055342866,
                "start": 1768586832.69573,
                "stop": 1768586832.70119,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestACCSystem object at 0x7ce3029ea0f0>\n\n    @pytest.fixture\n    def acc_module(self):\n        spec = importlib.util.spec_from_file_location('acc_system', '/root/acc_system.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afed9280>\npath = '/root/acc_system.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/acc_system.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestACCSystem::test_acc_cruise_mode",
                "status": "failed",
                "duration": 0.0002452530006848974,
                "start": 1768586832.7013638,
                "stop": 1768586832.7067695,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestACCSystem object at 0x7ce3029e8b60>\n\n    @pytest.fixture\n    def acc_module(self):\n        spec = importlib.util.spec_from_file_location('acc_system', '/root/acc_system.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afed5370>\npath = '/root/acc_system.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/acc_system.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestACCSystem::test_acc_follow_mode",
                "status": "failed",
                "duration": 0.00022404600076697534,
                "start": 1768586832.7069764,
                "stop": 1768586832.7116954,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestACCSystem object at 0x7ce302c59880>\n\n    @pytest.fixture\n    def acc_module(self):\n        spec = importlib.util.spec_from_file_location('acc_system', '/root/acc_system.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afed3e90>\npath = '/root/acc_system.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/acc_system.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestACCSystem::test_acc_emergency_mode",
                "status": "failed",
                "duration": 0.00020599600065906998,
                "start": 1768586832.7118623,
                "stop": 1768586832.7165866,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestACCSystem object at 0x7ce302c596a0>\n\n    @pytest.fixture\n    def acc_module(self):\n        spec = importlib.util.spec_from_file_location('acc_system', '/root/acc_system.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afedad80>\npath = '/root/acc_system.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/acc_system.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestACCSystem::test_acc_return_format",
                "status": "failed",
                "duration": 0.00020694799968623556,
                "start": 1768586832.7167652,
                "stop": 1768586832.7297702,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestACCSystem object at 0x7ce302c58800>\n\n    @pytest.fixture\n    def acc_module(self):\n        spec = importlib.util.spec_from_file_location('acc_system', '/root/acc_system.py')\n        module = importlib.util.module_from_spec(spec)\n>       spec.loader.exec_module(module)\n\n/tests/test_outputs.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n<frozen importlib._bootstrap_external>:991: in exec_module\n    ???\n<frozen importlib._bootstrap_external>:1128: in get_code\n    ???\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7ce2afedc590>\npath = '/root/acc_system.py'\n\n>   ???\nE   FileNotFoundError: [Errno 2] No such file or directory: '/root/acc_system.py'\n\n<frozen importlib._bootstrap_external>:1186: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestTuningResults::test_tuning_yaml_structure",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.00021103499966557138,
                "start": 1768586832.729921,
                "stop": 1768586832.7336848,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestTuningResults object at 0x7ce302c59130>\n\n    def test_tuning_yaml_structure(self):\n        \"\"\"Step 4: exactly pid_speed and pid_distance sections with kp, ki, kd\"\"\"\n        import yaml\n>       with open('/root/tuning_results.yaml', 'r') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: '/root/tuning_results.yaml'\n\n/tests/test_outputs.py:179: FileNotFoundError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::TestTuningResults::test_gains_are_tuned",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.00018155000088881934,
                "start": 1768586832.7338254,
                "stop": 1768586832.7371871,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestTuningResults object at 0x7ce302c59640>\n\n    def test_gains_are_tuned(self):\n        \"\"\"Step 4: must be different from initial values (Kp=0.1, Ki=0.01, Kd=0.0)\"\"\"\n        import yaml\n>       with open('/root/tuning_results.yaml', 'r') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: '/root/tuning_results.yaml'\n\n/tests/test_outputs.py:190: FileNotFoundError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::TestTuningResults::test_gains_in_range",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.000185958000656683,
                "start": 1768586832.7373176,
                "stop": 1768586832.7411838,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestTuningResults object at 0x7ce302c59610>\n\n    def test_gains_in_range(self):\n        \"\"\"Step 4: Kp in (0, 10), Ki in [0, 5), Kd in [0, 5)\"\"\"\n        import yaml\n>       with open('/root/tuning_results.yaml', 'r') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: '/root/tuning_results.yaml'\n\n/tests/test_outputs.py:200: FileNotFoundError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::TestSimulationResults::test_csv_columns",
                "status": "failed",
                "duration": 0.0002756729991233442,
                "start": 1768586832.7413352,
                "stop": 1768586832.77538,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSimulationResults object at 0x7ce302c50860>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSimulationResults::test_row_count",
                "status": "failed",
                "duration": 0.00029720799921051366,
                "start": 1768586832.7755651,
                "stop": 1768586832.8090923,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSimulationResults object at 0x7ce302c50650>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSimulationResults::test_timestamps_match",
                "status": "failed",
                "duration": 0.000317839000672393,
                "start": 1768586832.8093295,
                "stop": 1768586832.854003,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSimulationResults object at 0x7ce302c52cc0>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSimulationResults::test_acceleration_varies",
                "status": "failed",
                "duration": 0.0003002960002049804,
                "start": 1768586832.8542032,
                "stop": 1768586832.887728,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSimulationResults object at 0x7ce302c536b0>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSimulationResults::test_modes_valid",
                "status": "failed",
                "duration": 0.0002955110003313166,
                "start": 1768586832.8879664,
                "stop": 1768586832.9297063,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSimulationResults object at 0x7ce302c52e70>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestReport::test_report_keywords",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0002216829989265534,
                "start": 1768586832.929902,
                "stop": 1768586832.9334009,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestReport object at 0x7ce302c507a0>\n\n    def test_report_keywords(self):\n        \"\"\"Step 6: includes words design, tuning, result\"\"\"\n>       with open('/root/acc_report.md', 'r') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: '/root/acc_report.md'\n\n/tests/test_outputs.py:250: FileNotFoundError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::TestSpeedControl::test_rise_time",
                "status": "failed",
                "duration": 0.0002664759986146237,
                "start": 1768586832.9335532,
                "stop": 1768586832.9669492,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSpeedControl object at 0x7ce302c50b60>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:263: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSpeedControl::test_overshoot",
                "status": "failed",
                "duration": 0.00029885299954912625,
                "start": 1768586832.9671476,
                "stop": 1768586833.0010428,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSpeedControl object at 0x7ce302b4cd70>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:263: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSpeedControl::test_steady_state_error",
                "status": "failed",
                "duration": 0.0002805900003295392,
                "start": 1768586833.0012248,
                "stop": 1768586833.0461218,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSpeedControl object at 0x7ce302b4c830>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:263: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestDistanceControl::test_steady_state_error",
                "status": "failed",
                "duration": 0.0003195240005879896,
                "start": 1768586833.0463138,
                "stop": 1768586833.0794475,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestDistanceControl object at 0x7ce302b4f7d0>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestDistanceControl::test_distance_overshoot",
                "status": "failed",
                "duration": 0.000411830999837548,
                "start": 1768586833.0797675,
                "stop": 1768586833.1147828,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestDistanceControl object at 0x7ce302b4f860>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSafety::test_minimum_distance",
                "status": "failed",
                "duration": 0.00033585399978619535,
                "start": 1768586833.1150286,
                "stop": 1768586833.1601014,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSafety object at 0x7ce302c53950>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:320: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSafety::test_emergency_mode_triggered",
                "status": "failed",
                "duration": 0.00030388199957087636,
                "start": 1768586833.1603181,
                "stop": 1768586833.1927164,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSafety object at 0x7ce302c50710>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:320: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSafety::test_emergency_ttc_and_accel",
                "status": "failed",
                "duration": 0.00027968600079475436,
                "start": 1768586833.1929147,
                "stop": 1768586833.2352707,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSafety object at 0x7ce302c58dd0>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:320: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSafety::test_acceleration_limits",
                "status": "failed",
                "duration": 0.00028081999971618643,
                "start": 1768586833.235466,
                "stop": 1768586833.277709,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSafety object at 0x7ce302c5a990>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:320: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSafety::test_speed_non_negative",
                "status": "failed",
                "duration": 0.00030823399993096245,
                "start": 1768586833.277924,
                "stop": 1768586833.3112285,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSafety object at 0x7ce3029e9d00>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:320: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestScenario::test_starts_at_rest",
                "status": "failed",
                "duration": 0.0003159480011163396,
                "start": 1768586833.3114395,
                "stop": 1768586833.3578794,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestScenario object at 0x7ce302b4e720>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestScenario::test_cruise_mode_early",
                "status": "failed",
                "duration": 0.00031112300075619714,
                "start": 1768586833.358098,
                "stop": 1768586833.3909845,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestScenario object at 0x7ce302b4f5f0>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestScenario::test_follow_mode_mid",
                "status": "failed",
                "duration": 0.0002819380006258143,
                "start": 1768586833.3911786,
                "stop": 1768586833.4317029,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestScenario object at 0x7ce302b4d2e0>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestScenario::test_emergency_mode_timing",
                "status": "failed",
                "duration": 0.00028169200049887877,
                "start": 1768586833.4318886,
                "stop": 1768586833.4640183,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestScenario object at 0x7ce302b4f620>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestScenario::test_cruise_mode_late",
                "status": "failed",
                "duration": 0.0003054690005228622,
                "start": 1768586833.4642177,
                "stop": 1768586833.5016222,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestScenario object at 0x7ce302b4f830>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestScenario::test_all_modes_exercised",
                "status": "failed",
                "duration": 0.0003074530004596454,
                "start": 1768586833.5018423,
                "stop": 1768586833.5482824,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestScenario object at 0x7ce302d5e060>\n\n    @pytest.fixture\n    def simulation_data(self):\n        import pandas as pd\n>       return pd.read_csv('/root/simulation_results.csv')\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026: in read_csv\n    return _read(filepath_or_buffer, kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620: in __init__\n    self._engine = self._make_engine(f, self.engine)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880: in _make_engine\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '/root/simulation_results.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '/root/simulation_results.csv'\n\n.cache/uv/archive-v0/ptzWvgiHccofoZ7G1Gz2E/lib/python3.12/site-packages/pandas/io/common.py:873: FileNotFoundError"
            },
            {
                "name": "test_outputs.py::TestSimulationExecution::test_simulation_runs",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.007789150999087724,
                "start": 1768586833.548511,
                "stop": 1768586833.5601494,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSimulationExecution object at 0x7ce302d5f320>\n\n    def test_simulation_runs(self):\n        \"\"\"Step 3: can be run directly with python3 simulation.py\"\"\"\n        import subprocess\n        import os\n        import shutil\n    \n        backup = '/root/simulation_results_backup.csv'\n        original = '/root/simulation_results.csv'\n        if os.path.exists(original):\n            shutil.copy(original, backup)\n    \n        try:\n            result = subprocess.run(\n                ['python3', 'simulation.py'],\n                capture_output=True, text=True, timeout=60, cwd='/root'\n            )\n>           assert result.returncode == 0\nE           assert 2 == 0\nE            +  where 2 = CompletedProcess(args=['python3', 'simulation.py'], returncode=2, stdout='', stderr=\"python3: can't open file '/root/simulation.py': [Errno 2] No such file or directory\\n\").returncode\n\n/tests/test_outputs.py:413: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::TestSimulationExecution::test_tuning_affects_behavior",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.00022014599926478695,
                "start": 1768586833.5603309,
                "stop": 1768586833.5639226,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "self = <test_outputs.TestSimulationExecution object at 0x7ce3029af800>\n\n    def test_tuning_affects_behavior(self):\n        \"\"\"Step 3: behavior must change when gains change\"\"\"\n        import yaml\n        import subprocess\n        import os\n        import shutil\n        import pandas as pd\n    \n>       with open('/root/tuning_results.yaml', 'r') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: '/root/tuning_results.yaml'\n\n/tests/test_outputs.py:428: FileNotFoundError",
                "message": "The test failed in the call phase"
            }
        ]
    }
}